# A. `WaveSimulator.Simulate`—完全実装仕様

## A-1. 前提・用語

* 盤：`W=10, H=8`（整数セル）。セル座標は `x∈[0..9], y∈[0..7]`。
* 入口ID：外周36点を時計回り（上10→右8→下10→左8）。
* 進行方位（4値）：`dir ∈ {+X(1,0), -X(-1,0), +Z(0,1), -Z(0,-1)}`
* **反射規則（固定）**：**色セル（赤/青/黄）へ入射した瞬間、常に「右に90°回転（clockwise）」**。
  例）`+X→-Z`, `-X→+Z`, `+Z→+X`, `-Z→-X`
* 色合成：**通過順不問の加法混色（R/G/Bビット）**。透明：無変化。黒：**吸収＝即終了**。
* ループ検出：状態 `(x,y,dir)` を既訪判定。既訪で `Looped` 終了。
* セーフティ：`maxSteps=4096` 超で強制終了（`Looped`扱い）。

> 注：盤に配置される「色セル」は **赤/青/黄/透明/黒** だけ。紫/橙/緑/灰は**結果色**としてのみ登場。

---

## A-2. 入口ID ↔ 初期状態 変換表（**唯一解**）

| 範囲 | 条件                 | 初期位置 (境界外)    | 初期方位     |
| -- | ------------------ | ------------- | -------- |
| 上辺 | `id=j (0..9)`      | `(x=j, y=-1)` | `dir=+Z` |
| 右辺 | `id=10+i (i=0..7)` | `(x=10, y=i)` | `dir=-X` |
| 下辺 | `id=18+j (j=0..9)` | `(x=j, y=8)`  | `dir=-Z` |
| 左辺 | `id=28+i (i=0..7)` | `(x=-1, y=i)` | `dir=+X` |

**最初の進入**：`pos += dir` で盤内へ（1ステップ目）。

---

## A-3. 色合成と最終色マッピング

内部は **R/G/B の3ビット**で保持（初期は 0 = White）。

* 追加：赤→`R=1<<0`、青→`B=1<<1`、黄→`Y=1<<2`
* 結果色ID（最後に一度だけ算出）：

| ビット   | 最終色ID     |
| ----- | --------- |
| `000` | White(0)  |
| `001` | Red(1)    |
| `010` | Blue(2)   |
| `100` | Yellow(3) |
| `011` | Purple(4) |
| `101` | Orange(5) |
| `110` | Green(6)  |
| `111` | Gray(7)   |

---

## A-4. 反射の右回転テーブル（**固定**）

| 入射dir              | 右回転後dir     |
| ------------------ | ----------- |
| `+X (dx=+1, dz=0)` | `-Z (0,-1)` |
| `-X (-1,0)`        | `+Z (0,+1)` |
| `+Z (0,+1)`        | `+X (+1,0)` |
| `-Z (0,-1)`        | `-X (-1,0)` |

---

## A-5. 出口IDの算出（**唯一解**）

| 条件（盤外）  | 出口ID                    |
| ------- | ----------------------- |
| `y==-1` | `id = x`（上辺0..9）        |
| `x==10` | `id = 10 + y`（右辺10..17） |
| `y==8`  | `id = 18 + x`（下辺18..27） |
| `x==-1` | `id = 28 + y`（左辺28..35） |

---

## A-6. 擬似コード（そのままUdonSharp化可能）

```pseudo
function Simulate(entryId, boardState[], boardLen):
    # --- 1) 入口→初期化 ---
    (x, y, dx, dz) = EntryToStart(entryId)    # A-2表
    rgbBits = 0                                # 0=White
    flags = 0                                  # bit0 Absorbed, bit2 Looped
    steps = 0
    visited = boolean[W][H][4] = false         # 10*8*4 = 320個

    while steps < 4096:
        # 2) 1マス進む（境界外→境界内へ）
        x += dx; y += dz; steps += 1

        # 3) 盤外→出口確定
        if x < 0 or x >= 10 or y < 0 or y >= 8:
            exitId = ComputeExitId(x, y)       # A-5表
            colorId = BitsToColorId(rgbBits)   # A-3表
            return (exitId, colorId, flags)

        # 4) ループ検出
        d4 = DirToIndex(dx, dz)                # +X=0, -X=1, +Z=2, -Z=3 など
        if visited[x][y][d4]:
            flags |= LOOPED
            exitId = 255
            colorId = BitsToColorId(rgbBits)
            return (exitId, colorId, flags)
        visited[x][y][d4] = true

        # 5) 盤セルの状態を取得
        c = CellColorAt(x, y, boardState, boardLen)   # 0=White,1=Red,2=Blue,3=Yellow,4..=unused
        if c == BLACK:
            flags |= ABSORBED
            return (255 /*no exit*/, /*color ignored*/, flags)

        if c == TRANSPARENT: 
            continue  # 色/進行ともに変化なし

        # 6) 色合成（R/G/Bビット更新）
        if c == RED:    rgbBits |= 0b001
        if c == BLUE:   rgbBits |= 0b010
        if c == YELLOW: rgbBits |= 0b100

        # 7) 直角反射（右回転）
        (dx, dz) = RotateRight(dx, dz)         # A-4表
    end while

    # 8) セーフティ越え→Looped扱い
    flags |= LOOPED
    return (255, BitsToColorId(rgbBits), flags)
```

> `CellColorAt` は `boardState`（A-7参照）を読み、**そのセルに色ピースがあるか**を返す関数。
> **形（Dot1/Line2/L3）**は `boardState` 内の `(x,y)` を原点とし、`rot` に応じてヒットテスト。

---

## A-7. `boardState` の読み方（配置ヒットテスト）

**エンコード（再掲）**

```
count : u8 (≤20)
for k in 0..count-1:
  colorId:u8     # 0..(White,Red,Blue,Yellow,Transparent,Black)
  shapeId:u8     # 0:Dot1, 1:Line2, 2:L3
  rot:u8         # 0,1,2,3 (90°刻み)
  x:u8, y:u8     # 原点セル
crc32:u32
```

**形のローカル座標**

* Dot1：`[(0,0)]`
* Line2：`[(0,0),(1,0)]`（rotで回転）
* L3：`[(0,0),(1,0),(0,1)]`（rotで回転）

**回転規則（右回転90°を rot 回）**

```
rot=0: (u,v) -> ( u, v)
rot=1: (u,v) -> ( v,-u)
rot=2: (u,v) -> (-u,-v)
rot=3: (u,v) -> (-v, u)
```

**ヒットテスト**

```
function CellColorAt(x,y, boardState):
  cnt = boardState[0]
  i = 1
  for k in 0..cnt-1:
     color = boardState[i+0]
     shape = boardState[i+1]
     rot   = boardState[i+2]
     ox    = boardState[i+3]
     oy    = boardState[i+4]
     i += 5

     for each (u,v) in ShapeLocal(shape):
         (rx, ry) = Rotate(u,v, rot)    # 上記規則
         if (ox+rx == x) and (oy+ry == y):
             return color               # 最初に命中した色を採用（配置は重ならない前提）
  return WHITE
```

---

## A-8. 代表テストベクトル（抜粋）

1. **空盤**：`entry=0(上A)` → 直進して `exit=18(下A)`、最終色=White、flags=0
2. **Red@ (2,0)**：`entry=0`（上A→列0）→進路に無し→`exit=18`、White
3. **Red@ (0,0)**：`entry=0` → (0,0) 命中→右回転 `+Z→+X` → 右外へ `exit=10+0=10`、最終色=Red
4. **Blue@ (5,2)**：`entry=5` → (5,2) 命中→右回転 → `exit=10+2=12`、最終色=Blue
5. **Red@ (4,3), Blue@ (6,3)**：二度命中→最終色=Purple、出口は進路で決まる
6. **Yellow@ (1,1), Black@ (3,1)**：Yellowで右回転後、Black命中→`exit=255, Absorbed`
7. **透明ライン配置**：色変化・方向変化とも無し→通常出口
8. **反射ループ**（L3で閉路）：`flags|=Looped, exit=255`、色は通過色の合成結果

> 実装後は **36入口 × 代表盤**（Dot/Line/L3×各色）で**一致率100%**を確認。

---

# B. TransferBoard—受け渡しチャンク設計

**前提の現実**：VRChat/Udon は**特定プレイヤーだけ**に秘密裏にデータを送る仕組みを持ちません。
よって「完全非公開のまま新Ownerへだけ渡す」は**原理的に困難**です。
本設計では以下の**二段階方針**を採用します。

## B-0. 方針（推奨順）

1. **Primary：Seed再生成（決定論）**

   * PRNGと配置アルゴリズムを**バージョン固定**＆**整数演算のみ**にして、**新OwnerがSeedから盤を再生成**。
   * 生成後 `crc32==boardHash` を検証。**一致すれば完了**（最速・最小漏洩）。

2. **Fallback：公開チャンク同期**（やむを得ない時のみ）

   * **公開**前提で `boardState` を**分割（チャンク）→Synced** で送る。
   * サイズは最大でも ~105B なので**通常は単発**（≤900B）。
   * これにより「遅参/所有者交代直後でも確実復元」が担保される（**非公開性は放棄**）。

以下、**両方式の実装仕様**。

---

## B-1. Primary：決定論再生成仕様

### B-1-1. PRNG（xorshift32・固定）

```csharp
uint rng;
void rng_seed(uint seed) { rng = seed ^ 0x9E3779B9u; }  // 黄金数XORで撹拌
uint rng_u32() {
    uint x = rng;
    x ^= x << 13; x ^= x >> 17; x ^= x << 5;
    rng = x; return x;
}
int rng_range(int lo, int hi) { // [lo, hi] inclusive
    uint span = (uint)(hi - lo + 1);
    return lo + (int)(rng_u32() % span);
}
```

> **全プラットフォーム一致**（整数のみ、未定義動作なし）。

### B-1-2. 生成アルゴリズム（**逐次充填・規則固定**）

1. **色順**：`[Red, Blue, Yellow]`（※透明/黒は別枠で後述）
2. **形順**：`[Dot1, Line2, L3]`
3. **ピース数**：各色 `cnt = rng_range(0, 5)`、総占有 `≤20` を超えないよう削減
4. **配置候補走査順**：

   * **回転順**：`rot=0→1→2→3`
   * **位置順**：**行優先（y=0..H-1, x=0..W-1）**
5. **充填ルール**：重なり禁止。入れば確定。入らなければ次候補へ。
6. **透明/黒**：`cnt_transparent = rng_range(0, T)`、`cnt_black = rng_range(0, B)` を同様に配置（T,Bは0〜2など小さく）

> 以上により、**同一Seed→唯一の盤**が整数演算だけで決まる。
> 生成後 `crc32(boardState[..])` → `boardHash` を算出し UdonSynced へ。

---

## B-2. Fallback：公開チャンク同期（**最小1発**）

### B-2-1. 同期フィールド（`GameController` へ追加）

```csharp
[UdonSynced] public byte boardVer = 1;
[UdonSynced] public byte boardLenSynced;          // 実長 (≤ 128)
[UdonSynced] public byte[] boardBlob = new byte[128]; // 実データ（公開）
[UdonSynced] public uint boardCrc;                // 冗長（検証用）
```

* **更新契機**：盤生成直後／盤変更時に Owner が書き込み→`RequestSerialization()`
* **受信側**：`boardLenSynced` > 0 なら `boardBlob[0..len-1]` が正本。`crc32` が `boardCrc` と一致することを確認して採用。
* **サイズ**：本件の`boardState`は概ね**~105B**のため**チャンク分割不要**。

  * もし将来拡張で >128B になるなら、下記B-2-2のチャンク分割へ。

### B-2-2.（将来）多チャンク化プロトコル

```text
Synced fields:
  xferSeq:u16      # 転送セッションID
  xferTotal:u8     # 総チャンク数
  xferIndex:u8     # 今送っているチャンク番号 (0..total-1)
  xferData:byte[180] # 1チャンク最大180B
  xferLen:u16      # xferDataの有効長
  xferHash:u32     # 全体CRC32（各チャンク同じ値）
```

* 手順：Ownerが `xferSeq++` して 0..`total-1` を順に送信（`RequestSerialization()` を各チャンクで）。
* 受信側：`xferSeq` が更新されたらバッファに蓄積し、`xferIndex==total-1` 受信後に `xferHash` 検証→確定。

> **注意**：これは**公開**になるため、**Primaryの決定論再生成が成功する限り不要**。不一致時のみ緊急用。

---

## B-3. 所有者交代時のフロー（最終版）

1. **通常**：新Ownerが `rng_seed(boardSeed)` で再生成→`crc32==boardHash` なら採用（**終了**）。
2. **不一致**：新Ownerは `needFallback=true` を内部に立てる。
3. **Fallback受信**：`boardLenSynced>0` か `xferSeq` が進むまで待ち、受信後 `crc32==boardCrc` で確定。
4. **確定後**：新Ownerが `RequestSerialization()` で公開状態（ログ/手番/Seed/Hash）を配布。

> 旧Ownerが突然離脱しても、**公開ボードが保持されていれば復元可能**。公開ボードを使いたくない場合は**Primaryを必ず成功させる**こと（本仕様の決定論生成で実現）。

---

## B-4. 例：`boardState` を `boardBlob` へ同期するUdonSharp断片

```csharp
// 盤生成直後（Owner側）
boardLen = EncodeBoardState(boardState /*~105B*/);
boardCrc = Crc32(boardState, 0, boardLen);

// Fallback公開（必要に応じて常時 or 不一致時のみ）
boardVer = 1;
boardLenSynced = (byte)boardLen;
for (int i=0;i<boardLen;i++) boardBlob[i] = boardState[i];
RequestSerialization();

// 受信側（新Owner）
if (boardLenSynced > 0) {
    byte[] tmp = new byte[boardLenSynced];
    for (int i=0;i<boardLenSynced;i++) tmp[i] = boardBlob[i];
    if (Crc32(tmp,0,boardLenSynced) == boardCrc) {
        // 正本として採用
        Copy(tmp -> boardState);
        boardLen = boardLenSynced;
    }
}
```

---

## B-5. 受け渡し時の落とし穴と対策

* **順序競合**：交代直後は `boardBlob` がまだ古い可能性 → `boardCrc` で検証。
* **改ざん**：公開である以上、**完全秘匿は不可能**（クライアント権限）。**ゲーム設計上の難読化**は本質解決にならない。
* **将来互換**：`boardVer` を必ず比較し、異なる場合は**生成器のバージョン差**として扱い、Fallbackでの受領を強制。

---

# まとめ／実装チェックリスト

* [ ] `WaveSimulator.Simulate` を本仕様どおり整数格子で実装（右回転固定）。
* [ ] `CellColorAt` の形ローテーションと命中判定をユニットテスト。
* [ ] `BitsToColorId` の7通り＋Whiteの計8色を網羅。
* [ ] 36入口×代表盤でOwner/非Owner結果一致を確認。
* [ ] 盤生成：`xorshift32`＋**色順/形順/回転順/位置順**を固定化し、`crc32==boardHash` を検証。
* [ ] Fallback公開同期（`boardBlob`）は**通常OFF**、不一致時のみONにする運用でも可。
* [ ] 所有者交代後の復元フローを実機で確認（ClientSimは補助）。
